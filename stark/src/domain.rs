use ark_ff::PrimeField;
use polynomial::univariate_poly::UnivariatePolynomial;

struct Domain<F> {
    generator: F,
}

// TODO: look into moving the domain halving logic here

impl<F: PrimeField> Domain<F> {
    /// Create a new domain for field F that enumerates the nth roots of F
    fn instantiate_from_nth_root(n: u64) -> Self {
        let nth_root_generator = F::get_root_of_unity(n).unwrap();
        Self {
            generator: nth_root_generator,
        }
    }

    /// Evaluate a polynomial at the full domain generated by the generator
    fn evaluate_poly_at_domain(&self, poly: &UnivariatePolynomial<F>) -> Vec<F> {
        let mut evaluations = vec![];
        let mut current_element = self.generator;
        while current_element != F::one() {
            evaluations.push(poly.evaluate(&current_element));
            current_element = current_element * self.generator;
        }
        evaluations.push(poly.evaluate(&current_element));
        evaluations
    }
}

#[cfg(test)]
mod tests {
    use crate::domain::Domain;
    use crate::Fq;
    use ark_ff::{FftField, Field};
    use polynomial::univariate_poly::UnivariatePolynomial;

    #[test]
    fn instantiate_domain_for_nth_root_of_unity() {
        let domain_64 = Domain::<Fq>::instantiate_from_nth_root(64);
        assert_eq!(domain_64.generator.pow(&[64]), Fq::from(1));
    }

    // #[test]
    // fn blam() {
    //     // 2x^2 + 3x + 4
    //     let p = UnivariatePolynomial::<Fq>::new(vec![Fq::from(4), Fq::from(3), Fq::from(2)]);
    //
    //     let m = Fq::get_root_of_unity(4).unwrap();
    //
    //     let evaluations = evaluate_poly_at_domain(m, &p);
    //     dbg!(evaluations);
    // }
}
