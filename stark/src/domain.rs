use ark_ff::PrimeField;
use polynomial::univariate_poly::UnivariatePolynomial;

struct Domain<F> {
    generator: F,
}

// TODO: look into moving the domain halving logic here

impl<F: PrimeField> Domain<F> {
    /// Create a new domain for field F that enumerates the nth roots of F
    fn instantiate_from_nth_root(n: u64) -> Self {
        let nth_root_generator = F::get_root_of_unity(n).unwrap();
        Self {
            generator: nth_root_generator,
        }
    }

    /// Evaluate a polynomial at the full domain generated by the generator
    fn evaluate_poly_at_domain(&self, poly: &UnivariatePolynomial<F>) -> Vec<F> {
        let mut evaluations = vec![];
        let mut current_element = self.generator;
        while current_element != F::one() {
            evaluations.push(poly.evaluate(&current_element));
            current_element = current_element * self.generator;
        }
        evaluations.push(poly.evaluate(&current_element));
        evaluations
    }
}

#[cfg(test)]
mod tests {
    use crate::domain::Domain;
    use crate::Fq;
    use ark_ff::{FftField, Field};
    use polynomial::univariate_poly::UnivariatePolynomial;

    #[test]
    fn instantiate_domain_for_nth_root_of_unity() {
        let domain_64 = Domain::<Fq>::instantiate_from_nth_root(64);
        assert_eq!(domain_64.generator.pow(&[64]), Fq::from(1));
    }

    #[test]
    fn evaluate_poly_at_domain() {
        let p = UnivariatePolynomial::<Fq>::new(vec![Fq::from(4), Fq::from(3), Fq::from(2)]);
        let domain_32 = Domain::<Fq>::instantiate_from_nth_root(32);
        assert_eq!(domain_32.generator.pow(&[32]), Fq::from(1));
        let evaluations = domain_32.evaluate_poly_at_domain(&p);
        assert_eq!(evaluations.len(), 32);
    }
}
