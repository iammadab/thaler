use crate::circom_gkr::circuit::program_circuit;
use crate::circom_gkr::program::R1CSProgram;
use crate::gkr::gkr::{GKRProof, GKRProve, GKRVerify};
use ark_ff::PrimeField;

// TODO: add documentation
// prover takes the witness and generates a gkr proof given some program
// TODO: witness value should be generated by the prover
//  consider making a prove with witness function
fn prove<F: PrimeField>(
    program: R1CSProgram<F>,
    witness: Vec<F>,
) -> Result<GKRProof<F>, &'static str> {
    let circuit = program_circuit(program);
    let evaluations = circuit.evaluate(witness).unwrap();
    GKRProve(circuit, evaluations)
}

// TODO: add documentation
fn verify<F: PrimeField>(
    program: R1CSProgram<F>,
    witness: Vec<F>,
    proof: GKRProof<F>,
) -> Result<bool, &'static str> {
    let circuit = program_circuit(program);
    // TODO: is this a sufficient check
    // if proof.sumcheck_proofs[0].sum != 0 {
    //     panic!("output mle must eval to 0");
    // }
    GKRVerify(circuit, witness, proof)
}

// TODO: write test that has correct witness structure but doesn't satisfy all constraints
//   should be able to generate proof but fail to verify because of the sum section

// TODO: write test that has correct witness structure + satisfies all constraints
//   all checks should pass

// TODO: figure out how to force the witness values for the constants

#[cfg(test)]
mod tests {
    use crate::circom_gkr::circuit::program_circuit;
    use crate::circom_gkr::circuit::tests::x_cube;
    use crate::circom_gkr::proof::prove;
    use ark_bls12_381::Fr;

    #[test]
    fn test_prove_verify_does_not_satisfy_constraint() {
        // program
        // x * x = a
        // a * x = b

        // invalid witness
        // x = 3
        // a = 10
        // b = 30
        // input structure [1, x, a, b, 0, -1]
        // TODO: enforce witness constants
        let proof = prove(
            x_cube(),
            vec![
                Fr::from(1),
                Fr::from(3),
                Fr::from(10),
                Fr::from(30),
                Fr::from(0),
                Fr::from(-1),
            ],
        )
        .unwrap();
        todo!()
    }
}
